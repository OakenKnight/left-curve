import * as crypto from "crypto";
import * as fs from "fs";
import {
  Bip39,
  EnglishMnemonic,
  Secp256k1,
  Secp256k1Keypair,
  Sha256,
  Slip10,
  Slip10Curve,
  stringToPath,
} from "@cosmjs/crypto";
import { encodeBase64, encodeBigEndian32, encodeUtf8, decodeBase64, serialize } from "./serde";
import { Message, Tx } from "./types";

// cwcli uses 50,000 iterations in debug mode and 600,000 in release mode
const PBKDF2_ITERATIONS = 50_000 /* 600_000 */;
const PBKDF2_KEY_LEN = 32;

/**
 * The JSON keystore file generated by cwcli.
 */
type Record = {
  name: string;
  pubkey: string;
  salt: string;
  nonce: string;
  ciphertext: string;
};

/**
 * An secp256k1 private key, with useful methods.
 */
export class SigningKey {
  private keyPair: Secp256k1Keypair;

  /**
   * Do not use; use `fromMnemonic` or `fromFile` instead.
   */
  private constructor(keyPair: Secp256k1Keypair) {
    this.keyPair = keyPair;
  }

  /**
   * Derive an secp256k1 privatekey from the given English mnemonic and BIP-44
   * coin type.
   */
  public static async fromMnemonic(mnemonic: string, coinType = 60): Promise<SigningKey> {
    const englishMnemonic = new EnglishMnemonic(mnemonic);
    const seed = await Bip39.mnemonicToSeed(englishMnemonic);
    const hdPath = stringToPath(`m/44'/${coinType}'/0'/0/0`);
    const slip10Res = Slip10.derivePath(Slip10Curve.Secp256k1, seed, hdPath);
    const keyPair = await Secp256k1.makeKeypair(slip10Res.privkey);
    return new SigningKey(keyPair);
  }

  /**
   * Open an encrypted keystore file generated by cwcli.
   */
  public static async fromFile(path: string, password: string): Promise<SigningKey> {
    const recordStr = fs.readFileSync(path, { encoding: "utf8" });
    const { salt, nonce, ciphertext } = JSON.parse(recordStr) as Record;
    const passwordHash = crypto.pbkdf2Sync(
      encodeUtf8(password),
      decodeBase64(salt),
      PBKDF2_ITERATIONS,
      PBKDF2_KEY_LEN,
      "sha256",
    );
    const decipher = crypto.createDecipheriv("aes-256-gcm", passwordHash, decodeBase64(nonce));
    const decrypted = decipher.update(decodeBase64(ciphertext));
    const privkey = decrypted.subarray(0, decrypted.length - 16); // crop the AES auth tag
    const keyPair = await Secp256k1.makeKeypair(privkey);
    return new SigningKey(keyPair);
  }

  /**
   * Create and sign a transaction.
   */
  public async createAndSignTx(
    msgs: Message[],
    sender: string,
    chainId: string,
    sequence: number,
  ): Promise<Tx> {
    const signBytes = createSignBytes(msgs, sender, chainId, sequence);
    const signature = await Secp256k1.createSignature(signBytes, this.keyPair.privkey);
    return {
      sender,
      msgs,
      credential: encodeBase64(signature.toDer()),
    };
  }

  public privKey(): Uint8Array {
    return this.keyPair.privkey;
  }

  public pubKey(): Uint8Array {
    return Secp256k1.compressPubkey(this.keyPair.pubkey);
  }
}

/**
 * Generate sign byte that the cw-account contract expects.
 */
export function createSignBytes(
  msgs: Message[],
  sender: string,
  chainId: string,
  sequence: number,
): Uint8Array {
  const hasher = new Sha256();
  hasher.update(encodeUtf8(serialize(msgs)));
  hasher.update(encodeUtf8(sender));
  hasher.update(encodeUtf8(chainId));
  hasher.update(encodeBigEndian32(sequence));
  return hasher.digest();
}
