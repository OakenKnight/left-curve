import { sha256 } from "@cosmjs/crypto";
import { Message, SigningKey, decodeBase64, encodeBase64, encodeHex } from "@cwsoftware/cw.js";
import { getBIP44AddressKeyDeriver } from "@metamask/key-tree";
import {
  Component,
  Json,
  OnRpcRequestHandler,
  address,
  divider,
  heading,
  panel,
  row,
  text,
} from "@metamask/snaps-sdk";

/**
 * The BIP-44 coin type of Cosmos, which we use also for CWD chains.
 *
 * Ideally we want to use coin type 60 so that we get the same public key as
 * Ethereum. However, MetaMask does not allow Snaps to request entropies with
 * coin type 60. The rationale is the `eth_requestAccounts` instead:
 * https://github.com/MetaMask/snaps/issues/1665
 *
 * However, this doesn't work for us because we don't want to use the Ethereum
 * _accounts_, we want to use the Ethereum _public keys_ and then we're going to
 * derive accounts addresses in a different way from Ethereum's.
 *
 * So for now it seems using a different coin type is the only way and we choose
 * Cosmos'.
 */
const COSMOS_COIN_TYPE = 118;

/**
 * Data that the webapp must provide the Snap in order to sign a transaction.
 */
export type SignTransactionParams = {
  readonly msgs: Message[];
  readonly sender: string;
  readonly chainId: string;
  readonly sequence: number;
};

/**
 * Logics for handling RPC requests.
 */
export const onRpcRequest: OnRpcRequestHandler = async ({ request }): Promise<Json> => {
  switch (request.method) {
    case "getPublicKey": {
      const signingKey = await generateSecp256k1KeyPair();
      // MetaMask requires us to return a `Json` type, but our public key is an
      // Uint8Array. therefore we have to encode the public key into a type that
      // satisfies the `Json` interface. here I choose to encode it to a `string`
      // in base64. casting to a `number[]` may also be an option; not sure which
      // one is more efficient, but for users the difference is probably negligible.
      return encodeBase64(signingKey.publicKey());
    }
    case "signTransaction": {
      const params = request.params as unknown as SignTransactionParams;
      const signature = await signTransaction(params);
      // encode the signature to base64 followin the same logic as above
      return encodeBase64(signature);
    }
    default: {
      throw new Error(`Unknown method: ${request.method}`);
    }
  }
};

/**
 * Retrieve an entropy from MetaMask and use it to generate an Secp256k1 key pair.
 * @returns The generated Secp256k1 key pair.
 */
export async function generateSecp256k1KeyPair(): Promise<SigningKey> {
  // API reference for the `snap_getBip44Entropy` method:
  // https://docs.metamask.io/snaps/reference/snaps-api/#snap_getbip44entropy
  const hdNode = await snap.request({
    method: "snap_getBip44Entropy",
    params: {
      coinType: COSMOS_COIN_TYPE,
    },
  });

  const deriver = await getBIP44AddressKeyDeriver(hdNode);
  const key = await deriver(0);
  if (!key.privateKeyBytes) {
    throw new Error("Failed to retrieve private key from MetaMask");
  }
  return await SigningKey.fromPrivateKey(key.privateKeyBytes);
}

/**
 * Sign a transaction. The private key is generated by entrophy provided by
 * MetaMask.
 * @param params Parameters necessary for signing the transaction, including the
 * messages, the chain ID, the signer address, and the signer's sequence number.
 * @returns The signature bytes.
 */
export async function signTransaction({
  sender,
  chainId,
  sequence,
  msgs,
}: SignTransactionParams): Promise<Uint8Array> {
  // display transaction details and let user confirm it
  //
  // API reference for the`snap_dialog` method:
  // https://docs.metamask.io/snaps/reference/snaps-api/#confirmation-dialog
  const confirmed = await snap.request({
    method: "snap_dialog",
    params: {
      type: "confirmation",
      content: panel([
        heading("Confirm transaction"),
        row("Sender", address(sender.toString())),
        row("Chain ID", text(chainId)),
        row("Sequence", text(sequence.toString())),
        ...displayMessages(msgs),
      ]),
    },
  });

  if (!confirmed) {
    throw new Error("User denied transaction");
  }

  // user has confirmed the transaction. now we request the entropy from
  // MetaMask, generate the private key, and sign the transaction.
  const signingKey = await generateSecp256k1KeyPair();

  // return the signed transaction to the webapp.
  // the webapp will handle transaction broadcasting.
  return await signingKey.signTx(msgs, sender, chainId, sequence);
}

/**
 * Convert a list of messages to Snap components so that they can be displayed
 * on the MetaMask wallet interface.
 * @param msgs Messages to be displayed
 * @returns A list of components based on the messages.
 */
export function displayMessages(msgs: Message[]): Component[] {
  let components: Component[] = [];
  for (const [idx, msg] of msgs.entries()) {
    components.push(divider());
    if ("updateConfig" in msg) {
      const { newCfg } = msg.updateConfig;
      components.concat([
        row(`message #${idx + 1}`, text("update config")),
        row("new config", text(JSON.stringify(newCfg))),
      ]);
    } else if ("transfer" in msg) {
      const { to, coins } = msg.transfer;
      components = components.concat([
        row(`message #${idx + 1}`, text("transfer")),
        row("to", address(to.toString())),
        row("coins", text(JSON.stringify(coins))), // TODO: better stringification of coins
      ]);
    } else if ("storeCode" in msg) {
      const wasmByteCode = decodeBase64(msg.storeCode.wasmByteCode);
      const codeHash = sha256(wasmByteCode);
      const codeSize = Math.floor(wasmByteCode.length / 1024);
      components = components.concat([
        row(`message #${idx + 1}`, text("store code")),
        row("code hash", text(encodeHex(codeHash))),
        row("code size", text(`${codeSize} kB`)),
      ]);
    } else if ("instantiate" in msg) {
      const { codeHash, msg: initMsg, salt, funds, admin } = msg.instantiate;
      components = components.concat([
        row(`message #${idx + 1}`, text("instantiate")),
        row("code hash", text(codeHash)),
        row("msg", text(atob(initMsg))),
        row("salt", text(salt)),
        row("funds", text(JSON.stringify(funds))),
      ]);
      if (admin) {
        components.push(row("admin", address(admin.toString())));
      }
    } else if ("execute" in msg) {
      const { contract, msg: execMsg, funds } = msg.execute;
      components = components.concat([
        row(`message #${idx + 1}`, text("execute")),
        row("contract", address(contract.toString())),
        row("msg", text(atob(execMsg))),
        row("funds", text(JSON.stringify(funds))),
      ]);
    } else if ("migrate" in msg) {
      const { contract, newCodeHash, msg: migrMsg } = msg.migrate;
      components = components.concat([
        row(`message #${idx + 1}`, text("migrate")),
        row("contract", address(contract.toString())),
        row("new code hash", text(newCodeHash)),
        row("msg", text(atob(migrMsg))),
      ]);
    }
  }
  return components;
}
